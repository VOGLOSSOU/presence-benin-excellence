# Architecture Clean - Explications d√©taill√©es

## üéØ Principes de l'architecture

### 1. **S√©paration des responsabilit√©s**
Chaque fichier a une responsabilit√© unique et claire.

### 2. **Modularit√©**
Chaque fonctionnalit√© est un module ind√©pendant (auth, users, forms, etc.)

### 3. **Maintenabilit√©**
Code facile √† lire, tester et modifier sans casser le reste.

### 4. **Scalabilit√©**
Facile d'ajouter de nouvelles fonctionnalit√©s sans toucher l'existant.

---

## üìä Flux de donn√©es (Request ‚Üí Response)

```
Client (Frontend)
    ‚Üì
Routes (routing)
    ‚Üì
Middlewares (validation, auth)
    ‚Üì
Controller (gestion req/res)
    ‚Üì
Service (logique m√©tier)
    ‚Üì
Prisma Client (ORM)
    ‚Üì
PostgreSQL (Database)
    ‚Üì
‚Üê Retour vers le Client
```

---

## üìÅ Explication des dossiers

### **prisma/**
- **schema.prisma** : D√©finition des mod√®les (tables)
- **seed.ts** : Cr√©er un admin par d√©faut au d√©marrage
- **migrations/** : Historique des changements de DB

### **src/config/**
Configuration globale du projet :
- **database.ts** : Instance unique de Prisma Client
- **env.ts** : Validation des variables d'environnement avec Zod
- **constants.ts** : Constantes r√©utilisables (ex: UUID_PREFIX = "BE-")

### **src/types/**
Types TypeScript personnalis√©s :
- **express.d.ts** : √âtendre Express (ajouter `req.user`)
- **index.ts** : Types globaux (interfaces, enums)

### **src/utils/**
Fonctions utilitaires r√©utilisables :
- **uuid-generator.ts** : G√©n√®re "BE-XXXXXX"
- **password.util.ts** : Hash et v√©rification passwords
- **jwt.util.ts** : Cr√©ation et v√©rification tokens JWT
- **response.util.ts** : Formatage uniforme des r√©ponses API
- **date.util.ts** : Manipulation dates (v√©rifier si dans intervalle, etc.)

### **src/middlewares/**
Intercepteurs entre routes et controllers :
- **auth.middleware.ts** : V√©rifie le JWT, extrait l'admin connect√©
- **validate.middleware.ts** : Valide les donn√©es avec Zod
- **error.middleware.ts** : Capture toutes les erreurs et formate la r√©ponse
- **logger.middleware.ts** : Log toutes les requ√™tes HTTP

### **src/validators/**
Sch√©mas de validation Zod pour chaque module :
```typescript
// Exemple : user.validator.ts
export const createUserSchema = z.object({
  lastName: z.string().min(2),
  firstName: z.string().min(2),
  title: z.enum(['ETUDIANT', 'PROFESSIONNEL', 'ELEVE', 'AUTRE'])
});
```

### **src/modules/**
Chaque module = une fonctionnalit√© compl√®te

#### Structure d'un module (exemple: **users/**)
```
users/
‚îú‚îÄ‚îÄ users.routes.ts      ‚Üí D√©finit les routes (GET, POST, etc.)
‚îú‚îÄ‚îÄ users.controller.ts  ‚Üí G√®re req/res, appelle le service
‚îú‚îÄ‚îÄ users.service.ts     ‚Üí Logique m√©tier, appelle Prisma
‚îî‚îÄ‚îÄ users.types.ts       ‚Üí Types sp√©cifiques au module
```

**Exemple de flux dans le module users :**
```typescript
// 1. Route
router.get('/:id', getUserController);

// 2. Controller
export const getUserController = async (req, res, next) => {
  const user = await userService.findById(req.params.id);
  res.json(user);
};

// 3. Service
export const findById = async (id: string) => {
  return await prisma.user.findUnique({ where: { id } });
};
```

### **src/shared/**
Code partag√© entre tous les modules :

#### **errors/**
Classes d'erreurs personnalis√©es :
```typescript
class NotFoundError extends AppError {
  constructor(message: string) {
    super(message, 404);
  }
}

// Usage
throw new NotFoundError('User not found');
```

#### **interfaces/**
Interfaces r√©utilisables pour garantir la coh√©rence :
```typescript
interface IController {
  handle(req: Request, res: Response, next: NextFunction): Promise<void>;
}
```

---

## üîÑ Modules expliqu√©s

### **1. auth/** - Authentification Admin
- `POST /api/auth/login` : Connexion admin
- `POST /api/auth/register` : Cr√©er un nouvel admin (super_admin only)
- G√©n√®re un JWT pour les requ√™tes prot√©g√©es

### **2. users/** - Gestion Visiteurs
- `GET /api/users` : Liste tous les visiteurs (admin)
- `GET /api/users/:id` : D√©tails d'un visiteur
- `PUT /api/users/:id` : Modifier un visiteur (admin only)
- `DELETE /api/users/:id` : Supprimer un visiteur

### **3. enrollment/** - Enr√¥lement
- `POST /api/enrollment` : Cr√©er un nouveau visiteur + UUID
- Rempli automatiquement les `UserFieldValue`
- Retourne l'UUID g√©n√©r√© (BE-XXXXXX)

### **4. forms/** - Formulaires dynamiques
- `GET /api/forms` : Liste des formulaires
- `POST /api/forms` : Cr√©er un formulaire (admin)
- `PUT /api/forms/:id` : Modifier un formulaire
- `POST /api/forms/:id/fields` : Ajouter un champ
- `DELETE /api/forms/:id/fields/:fieldId` : Supprimer un champ

### **5. presence/** - Enregistrement pr√©sence
- `POST /api/presence` : Enregistrer une pr√©sence avec UUID
- **Logique automatique :**
  - Si formulaire = `simple_presence` ‚Üí type `SIMPLE`
  - Si formulaire = `arrival_departure` :
    - Premi√®re fois du jour ‚Üí `ARRIVAL`
    - Deuxi√®me fois ‚Üí `DEPARTURE`

### **6. admin/** - Dashboard Admin
- `GET /api/admin/dashboard` : Stats globales
- `GET /api/admin/users` : Liste pagin√©e visiteurs
- `GET /api/admin/presences` : Historique pr√©sences

### **7. reports/** - Rapports et Stats
- `GET /api/reports/daily` : Rapport journalier
- `GET /api/reports/user/:userId` : Historique d'un visiteur
- `GET /api/reports/export` : Export CSV/Excel

---

## ‚úÖ Avantages de cette architecture

### **1. Testabilit√©**
Chaque layer peut √™tre test√© ind√©pendamment :
- Services test√©s sans Express
- Controllers test√©s en mockant les services

### **2. R√©utilisabilit√©**
Les utils, validators, errors sont r√©utilisables partout.

### **3. Maintenabilit√©**
Pour ajouter une fonctionnalit√© :
1. Cr√©er un nouveau module dans `modules/`
2. Ajouter ses routes dans `app.ts`
3. Aucun impact sur le code existant

### **4. Clart√©**
En lisant la structure, on comprend imm√©diatement l'architecture.

### **5. Scalabilit√©**
Peut g√©rer des projets avec 50+ endpoints sans confusion.

---

## üé® Exemple concret : Enregistrement de pr√©sence

### **1. Client envoie :**
```json
POST /api/presence
{
  "uuidCode": "BE-8F92GHT"
}
```

### **2. Route (presence.routes.ts)**
```typescript
router.post('/', validate(createPresenceSchema), createPresenceController);
```

### **3. Middleware validate**
V√©rifie que `uuidCode` est bien fourni et valide.

### **4. Controller (presence.controller.ts)**
```typescript
export const createPresenceController = async (req, res, next) => {
  try {
    const presence = await presenceService.recordPresence(req.body.uuidCode);
    return successResponse(res, presence, 'Pr√©sence enregistr√©e', 201);
  } catch (error) {
    next(error);
  }
};
```

### **5. Service (presence.service.ts)**
```typescript
export const recordPresence = async (uuidCode: string) => {
  // 1. Trouver l'utilisateur
  const user = await prisma.user.findUnique({ where: { uuidCode } });
  if (!user) throw new NotFoundError('UUID invalide');
  
  // 2. D√©terminer le type (arrival/departure/simple)
  const presenceType = await determinePresenceType(user.id);
  
  // 3. Cr√©er la pr√©sence
  return await prisma.presence.create({
    data: { userId: user.id, presenceType, ... }
  });
};
```

### **6. Prisma ‚Üí PostgreSQL**
Ex√©cute l'INSERT et retourne la donn√©e.

### **7. Response au client**
```json
{
  "success": true,
  "message": "Pr√©sence enregistr√©e",
  "data": {
    "id": "...",
    "presenceType": "ARRIVAL",
    "timestamp": "2025-11-29T10:30:00Z"
  }
}
```

---



**Tu es pr√™t √† mettre en place cette architecture ?**